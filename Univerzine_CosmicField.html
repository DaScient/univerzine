<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <title>Univerzine — Cosmic Field</title>
 <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
 <!-- Enable full-screen app mode on iOS -->
 <meta name="apple-mobile-web-app-capable" content="yes">
 <style>
   /* Global reset & cosmic look */
   html, body {
     margin: 0;
     overflow: hidden;
     height: 100%;
     font-family: monospace;
     background: #000;
     color: #0f0;
   }
   canvas {
     display: block;
   }
   /* Terminal overlay styling */
   #terminal {
     position: absolute;
     top: 0;
     left: 0;
     width: 100%;
     height: 20%;
     background: rgba(0, 0, 0, 0.5);
     padding: 10px;
     overflow-y: auto;
     font-size: 13px;
     pointer-events: none;
     z-index: 10;
     white-space: pre-wrap;
   }
   /* Control panel styling (bottom left) */
   #controls {
     position: absolute;
     bottom: 20px;
     left: 20px;
     z-index: 20;
     background: rgba(0, 0, 0, 0.8);
     padding: 10px;
     border-radius: 5px;
     color: #fff;
     font-family: Arial, sans-serif;
     transition: opacity 0.5s ease;
     opacity: 0;
   }
   #controls:hover { opacity: 1; }
   .button, label {
     font-size: 13px;
     margin: 4px;
   }
   .button {
     background: #444;
     border: none;
     padding: 6px 10px;
     cursor: pointer;
     color: #fff;
   }
   .button:hover { background: #666; }
   select, input[type="checkbox"] {
     margin: 4px;
     padding: 2px;
   }
   /* Left panel styling for website links */
   #leftPanel {
     position: absolute;
     top: 50%;
     left: 0;
     transform: translate(0, -50%);
     background: rgba(0, 0, 0, 0.5);
     padding: 10px;
     border-top-right-radius: 10px;
     border-bottom-right-radius: 10px;
     opacity: 0;
     transition: opacity 0.5s ease;
     z-index: 20;
   }
   #leftPanel:hover { opacity: 1; }
   .leftLink {
     color: #fff;
     text-decoration: none;
     font-size: 14px;
     margin: 5px 0;
     display: block;
     transition: color 0.3s ease;
   }
   .leftLink:hover { color: #0f0; }
   /* Glitch effect CSS (optional) */
   @keyframes glitch {
     0% { filter: none; }
     25% { filter: contrast(150%) brightness(150%); }
     50% { filter: none; }
     75% { filter: contrast(200%) brightness(120%); }
     100% { filter: none; }
   }
   .glitch {
     animation: glitch 0.5s infinite;
   }

   /* ===== Immersive auto-hide UI baseline ===== */
   .ui {
     transition: opacity 0.5s ease, transform 0.5s ease;
     will-change: opacity, transform;
   }
   body.ui-hidden .ui {
     opacity: 0;
   }

   /* VR HUD + calibration prompt */
   #vrHUD{
     position:fixed; top:12px; right:12px; z-index:10050;
     font:12px/1.2 monospace; letter-spacing:0.08em;
     color:#00ff7b; background:rgba(0,0,0,.45);
     border:1px solid rgba(0,255,123,.25);
     border-radius:12px; padding:8px 10px;
     opacity:0; transform:translateY(-6px);
     pointer-events:none;
   }
   #vrHUD.active{ opacity:1; transform:translateY(0); }

   #vrCalibrateOverlay{
     position:fixed; inset:0; z-index:10060;
     display:none; align-items:center; justify-content:center;
     background:rgba(0,0,0,.55);
     backdrop-filter:saturate(120%) blur(10px);
   }
   #vrCalibrateOverlay.show{ display:flex; }
   #vrCalibrateCard{
     max-width:min(520px, 92vw);
     padding:18px 18px 14px;
     border-radius:18px;
     background:rgba(8,10,16,.72);
     border:1px solid rgba(255,255,255,.10);
     box-shadow:0 18px 60px rgba(0,0,0,.5);
     color:#e8fff3;
     font:14px/1.35 Arial, sans-serif;
   }
   #vrCalibrateCard h3{
     margin:0 0 8px 0; font:700 14px/1.2 monospace; color:#00ff7b; letter-spacing:.08em;
   }
   #vrCalibrateCard p{ margin:0 0 12px 0; opacity:.92; }
   #vrCalibrateCard .row{ display:flex; gap:10px; flex-wrap:wrap; }
   #vrCalibrateCard button{
     background:#0f1220; color:#00ff7b; border:1px solid rgba(0,255,123,.35);
     border-radius:12px; padding:10px 12px; font:12px monospace; cursor:pointer;
   }
   #vrCalibrateCard button:hover{ opacity:1; }
   #vrCalibrateCard .muted{ opacity:.75; font-size:12px; }

   /* VR mode: fade all 2D overlays except VR HUD + calibration overlay */
   body.vr-active #controls,
   body.vr-active #leftPanel,
   body.vr-active #terminal,
   body.vr-active #termToggle,
   body.vr-active #hudHover{
     opacity:0 !important;
     pointer-events:none !important;
     transform:translateY(-6px);
   }

</style>

  <!-- ⬇ Enhancements injected: meta + terminal hover CSS (non-destructive) -->
  <meta name="description" content="Univerzine — an interactive cosmic magazine in motion (tech, science, big data, and more)." />
  <link rel="icon" href="./assets/logo.svg" type="image/svg+xml" />
  <meta property="og:title" content="Univerzine • Cosmic Magazine" />
  <meta property="og:description" content="Welcome to Univerzine! Drift through a living hyperspace of stories." />
  <meta property="og:image" content="./assets/og-preview.png" />

  <style>
    /* ===== Terminal → hover/keyboard toggle ===== */
    #hudHover{
      position:fixed; top:0; left:0; width:100%; height:10px;
      z-index:10001; background:transparent; pointer-events:auto;
    }
    #terminal{
      position:fixed; top:0; left:0; width:100%; max-height:30vh;
      background:rgba(0,0,0,.6); padding:10px; overflow:auto;
      font:13px/1.45 monospace; color:#00ff7b; z-index:10000;
      transform:translateY(-100%); opacity:0; transition:transform .22s ease, opacity .22s ease;
      box-shadow:0 14px 40px rgba(0,0,0,.35);
      border-bottom:1px solid rgba(255,255,255,.08);
      backdrop-filter:saturate(120%) blur(6px);
    }
    #terminal.is-open{ transform:translateY(0); opacity:1; }
    /* Reveal on edge hover OR hovering the panel */
    #hudHover:hover ~ #terminal, #terminal:hover{ transform:translateY(0); opacity:1; }

    /* Minimal toggle button (optional) */
    #termToggle{
      position:fixed; top:12px; right:12px; z-index:10002;
      background:#0f1220; color:#00ff7b; border:1px solid #264;
      border-radius:10px; padding:6px 10px; font:12px monospace; opacity:.85; cursor:pointer;
    }
    #termToggle:hover{ opacity:1 }
  </style>

</head>
<body>
 <!-- Three.js canvas -->
 <canvas id="cosmicCanvas"></canvas>
 <!-- Terminal overlay -->
 <div id="hudHover" aria-hidden="true"></div>
<button id="termToggle" class="ui" type="button" title="Toggle console (T)">LOG</button>
<div id="terminal" class="ui">UNIVERZINE INITIALIZING...</div>
<div id="vrHUD" class="ui">IMMERSIVE MODE ACTIVE</div>

<div id="vrCalibrateOverlay" aria-hidden="true">
  <div id="vrCalibrateCard" role="dialog" aria-modal="true">
    <h3>CALIBRATE GYRO CENTER</h3>
    <p>Hold your device in your natural “straight ahead” pose, then calibrate. (Touch/drag still moves you through space.)</p>
    <div class="row">
      <button id="vrCalibrateBtn" type="button">CALIBRATE</button>
      <button id="vrCloseCalibrateBtn" type="button">CLOSE</button>
      <button id="vrExitBtnTop" type="button">EXIT VR</button>
    </div>
    <div class="muted">Tip: iOS may ask permission for motion sensors. If denied, VR falls back gracefully.</div>
  </div>
</div>

 <!-- Control Panel (bottom left, hover to reveal) -->
 <div id="controls" class="ui">
   <label for="resolutionSelector">Resolution:</label>
   <select id="resolutionSelector">
     <option value="low">Low</option>
     <option value="medium" selected>Medium</option>
     <option value="high">High</option>
     <option value="ultra">Ultra</option>
     <option value="grandmaster">Grandmaster</option>
   </select>
   <button class="button" id="fullscreenBtn">Fullscreen</button>
   <button class="button" id="vrBtn">Enter VR</button>
   <button class="button" id="calibrateBtn">Calibrate</button>
   <button class="button" id="grandmasterBtn">Grandmaster</button>
   <br>
   <label><input type="checkbox" id="toggleAudio" checked> Audio Sensitivity</label>
   <label><input type="checkbox" id="toggleOrientation" checked> Device Orientation</label>
   <label><input type="checkbox" id="toggleTouch" checked> Touch Controls</label>
   <!-- New Auto-Camera Angling Option -->
   <label><input type="checkbox" id="toggleAutoCamera"> Auto-Camera Angling</label>
   <label><input type="checkbox" id="toggleGlitch"> Glitch Effects</label>
   <label><input type="checkbox" id="toggleDynamic" checked> Dynamic Colors</label>
   <br>
   <label for="colorSchemeSelector">Color Scheme:</label>
   <select id="colorSchemeSelector">
     <option value="vibrant" selected>Vibrant</option>
     <option value="pastel">Pastel</option>
     <option value="neon">Neon</option>
     <option value="cosmic">Cosmic</option>
   </select>
 </div>
 <!-- Left Panel with Website Links (hover over the left edge to reveal) -->
 <div id="leftPanel" class="ui">
   <a href="https://donutz.ai" target="_blank" class="leftLink">donutz.ai</a>
   <a href="https://dascient.com" target="_blank" class="leftLink">dascient.com</a>
   <a href="https://gozaddy.ai" target="_blank" class="leftLink">gozaddy.ai</a>
 </div>

 <!-- Include Three.js from a CDN -->
 <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
 <script>
   /***********************************************************************
    * DASCIENT – CosmicDashboard (Augmented Reality Edition)
    *
    * This cosmic dashboard has been enhanced to allow you to freely swim
    * and rotate through a living, breathing universe. In addition to fluid
    * navigation, nebulas, particles, UFOs, audio responsiveness, and auto-camera
    * angling, we now introduce several exquisite, shimmering stars.
    *
    * Each interactive star is dynamic and vibrant. When clicked or hovered
    * over for longer than 3.1415 seconds, a zooming-in cosmic animation is triggered,
    * and you are redirected to:
    *
    * • A brilliant star: https://donutz.ai/stocks  
    * • An enigmatic star: https://donutz.ai/crypto  
    * • A wicked enigma: https://gozaddy.ai  
    * • A dark, glitched, anti-philosophical cosmic entity: https://xXDaemonLoverXx.ai  
    *
    * Enjoy the transcendent journey.
    ***********************************************************************/

   // Global variables
   let scene, camera, renderer, particleSystem, particleMaterial;
   let particleCount;
   const resolutionSettings = {
     low: 10000,
     medium: 20000,
     high: 50000,
     ultra: 100000,
     grandmaster: 200000
   };

   // Optional feature flags (from UI toggles)
   let audioEnabled = document.getElementById('toggleAudio').checked;
   let orientationEnabled = document.getElementById('toggleOrientation').checked;
   let touchEnabled = document.getElementById('toggleTouch').checked;
   let glitchEnabled = document.getElementById('toggleGlitch').checked;
   let dynamicColorsEnabled = document.getElementById('toggleDynamic').checked;
   let autoCameraEnabled = document.getElementById('toggleAutoCamera').checked;  // New auto-camera flag

   // Color scheme presets
   const colorSchemes = {
     vibrant: { r: 1.0, g: 0.2, b: 0.8 },
     pastel:  { r: 0.7, g: 0.5, b: 0.9 },
     neon:    { r: 0.0, g: 1.0, b: 0.8 },
     cosmic:  { r: 0.2, g: 0.0, b: 0.5 }
   };
   let selectedColorScheme = document.getElementById('colorSchemeSelector').value;
   let baseColor = Object.assign({}, colorSchemes[selectedColorScheme]);

   // Global variable for audio amplitude (0-256)
   let audioAverage = 0;

   // Randomize the background gradient on each refresh
   function randomBackground() {
     const randomColor = () => Math.floor(Math.random() * 156) + 100;
     const c1 = `rgb(${randomColor()}, ${randomColor()}, ${randomColor()})`;
     const c2 = `rgb(${randomColor()}, ${randomColor()}, ${randomColor()})`;
     document.body.style.background = `radial-gradient(circle, ${c1}, ${c2})`;
   }
   randomBackground();

   // Set up Three.js renderer, scene, and camera
   const canvas = document.getElementById('cosmicCanvas');
   renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
   renderer.setPixelRatio(window.devicePixelRatio);
   renderer.setSize(window.innerWidth, window.innerHeight);
   scene = new THREE.Scene();
   camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
   camera.position.z = 1000;
   // ===== Univerzine Neon Drive‑In Sign (in-world) =====
   let univerzineSign;
   function makeUniverzineSignTexture(){
     const c = document.createElement('canvas');
     c.width = 1024; c.height = 256;
     const ctx = c.getContext('2d');

     // Background is transparent; we paint glows + tube text
     ctx.clearRect(0,0,c.width,c.height);

     // Outer neon frame (rounded rect)
     const x=70, y=45, w=884, h=166, r=48;
     function roundRectPath(){
       ctx.beginPath();
       ctx.moveTo(x+r, y);
       ctx.arcTo(x+w, y,   x+w, y+h, r);
       ctx.arcTo(x+w, y+h, x,   y+h, r);
       ctx.arcTo(x,   y+h, x,   y,   r);
       ctx.arcTo(x,   y,   x+w, y,   r);
       ctx.closePath();
     }

     // Glow layers
     const glowColors = [
       'rgba(255, 120, 220, 0.20)', // pink
       'rgba(160, 110, 255, 0.16)', // purple
       'rgba(120, 220, 255, 0.18)', // baby blue
     ];
     for(let i=0;i<10;i++){
       ctx.save();
       ctx.lineWidth = 10 + i*6;
       ctx.strokeStyle = glowColors[i%glowColors.length];
       ctx.shadowBlur = 40 + i*10;
       ctx.shadowColor = glowColors[i%glowColors.length];
       roundRectPath();
       ctx.stroke();
       ctx.restore();
     }

     // Inner glass
     ctx.save();
     roundRectPath();
     ctx.fillStyle = 'rgba(10, 12, 20, 0.35)';
     ctx.fill();
     ctx.restore();

     // Tube text
     const text1 = "Welcome to Univerzine!";
     ctx.save();
     ctx.font = "900 86px Arial, sans-serif";
     ctx.textAlign = "center";
     ctx.textBaseline = "middle";

     // multi-stroke neon tubes
     const cx = c.width/2, cy = c.height/2 + 4;
     const strokes = [
       {w: 18, col: 'rgba(255, 130, 220, 0.85)', blur: 32},
       {w: 14, col: 'rgba(160, 120, 255, 0.82)', blur: 28},
       {w: 10, col: 'rgba(120, 235, 255, 0.88)', blur: 26},
     ];
     for(const s of strokes){
       ctx.lineWidth = s.w;
       ctx.strokeStyle = s.col;
       ctx.shadowBlur = s.blur;
       ctx.shadowColor = s.col;
       ctx.strokeText(text1, cx, cy);
     }
     // hot core
     const grad = ctx.createLinearGradient(cx-260, 0, cx+260, 0);
     grad.addColorStop(0, 'rgba(255, 170, 230, 1)');
     grad.addColorStop(0.5, 'rgba(210, 190, 255, 1)');
     grad.addColorStop(1, 'rgba(160, 245, 255, 1)');
     ctx.fillStyle = grad;
     ctx.shadowBlur = 14;
     ctx.shadowColor = 'rgba(255,255,255,0.7)';
     ctx.fillText(text1, cx, cy);
     ctx.restore();

     // subtle scanline shimmer
     ctx.save();
     ctx.globalCompositeOperation = 'screen';
     for(let yy=0; yy<c.height; yy+=6){
       ctx.fillStyle = (yy%12===0) ? 'rgba(255,255,255,0.020)' : 'rgba(255,255,255,0.010)';
       ctx.fillRect(0, yy, c.width, 1);
     }
     ctx.restore();

     const tex = new THREE.CanvasTexture(c);
     tex.anisotropy = 4;
     tex.needsUpdate = true;
     return tex;
   }

   function addUniverzineSign(){
     const tex = makeUniverzineSignTexture();
     const mat = new THREE.SpriteMaterial({
       map: tex,
       transparent: true,
       depthWrite: false,
       blending: THREE.AdditiveBlending,
     });
     univerzineSign = new THREE.Sprite(mat);
     univerzineSign.position.set(0, 0, 0);
     univerzineSign.scale.set(900, 225, 1);
     univerzineSign.userData = { baseY: 0, flickerSeed: Math.random()*9999 };
     scene.add(univerzineSign);
   }
   addUniverzineSign();

   // ===== Geolocation navigation (optional; best used in VR) =====
   let geoEnabled = false;
   let geoWatchId = null;
   let geoOrigin = null; // {lat, lon}
   let lastGeo = null;   // {lat, lon}
   const GEO_WORLD_SCALE = 2.0; // world units per meter (tune for feel)
   const GEO_MAX_STEP = 60;     // max world-units per update (prevents spikes)

   function metersDelta(from, to){
     // Approx conversion for small distances
     const lat1 = from.lat * Math.PI/180;
     const mPerDegLat = 111320;
     const mPerDegLon = 111320 * Math.cos(lat1);
     const dLatM = (to.lat - from.lat) * mPerDegLat;
     const dLonM = (to.lon - from.lon) * mPerDegLon;
     return { northM: dLatM, eastM: dLonM };
   }

   function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

   async function startGeo(){
     if (!('geolocation' in navigator)) {
       logToTerminal("Geolocation unavailable on this device/browser.");
       return false;
     }
     // iOS permission is implicit via prompt on watchPosition
     geoEnabled = true;
     geoOrigin = null;
     lastGeo = null;

     geoWatchId = navigator.geolocation.watchPosition((pos)=>{
       const cur = { lat: pos.coords.latitude, lon: pos.coords.longitude };
       if (!geoOrigin) { geoOrigin = cur; lastGeo = cur; logToTerminal("Geo lock acquired. Move to drift through space."); return; }
       const d = metersDelta(lastGeo, cur);
       lastGeo = cur;

       // Map movement: East/West -> X, North/South -> Z
       const dx = clamp(d.eastM * GEO_WORLD_SCALE, -GEO_MAX_STEP, GEO_MAX_STEP);
       const dz = clamp(-d.northM * GEO_WORLD_SCALE, -GEO_MAX_STEP, GEO_MAX_STEP);

       targetCameraPosition.x += dx;
       targetCameraPosition.z += dz;
     }, (err)=>{
       geoEnabled = false;
       logToTerminal("Geolocation error: " + err.message);
     }, { enableHighAccuracy: true, maximumAge: 250, timeout: 8000 });

     return true;
   }

   function stopGeo(){
     if (geoWatchId !== null) {
       navigator.geolocation.clearWatch(geoWatchId);
       geoWatchId = null;
     }
     geoEnabled = false;
   }

   // ===== VR / Gyro / Geo State =====
   let vrMode = false; // VR = immersive controls + UI rules (single-screen render)
// Device orientation tracking (stores latest readings; applied in animate() for smoothing)
   let deviceAlpha = 0, deviceBeta = 0, deviceGamma = 0;
   let screenOrientRad = 0;
   let gyroListenerAttached = false;

   // Calibration offset quaternion (re-centers current device pose as "forward")
   const gyroCalibrationOffset = new THREE.Quaternion(); // inverse of current device quaternion
   gyroCalibrationOffset.identity();
   let hasCalibratedThisSession = false;

   // Quat helper based on three.js DeviceOrientationControls (r128-era compatible)
   const zee = new THREE.Vector3(0, 0, 1);
   const euler = new THREE.Euler();
   const q0 = new THREE.Quaternion();
   const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // -PI/2 around X
   function setObjectQuaternion(quat, alpha, beta, gamma, orient) {
     // ZXY for the device, then adjust for camera and screen orientation
     euler.set(beta, alpha, -gamma, 'ZXY');
     quat.setFromEuler(euler);
     quat.multiply(q1);
     quat.multiply(q0.setFromAxisAngle(zee, -orient));
   }

   function updateScreenOrientation() {
     const angle = (screen.orientation && typeof screen.orientation.angle === 'number')
       ? screen.orientation.angle
       : (typeof window.orientation === 'number' ? window.orientation : 0);
     screenOrientRad = THREE.MathUtils.degToRad(angle);
   }
   updateScreenOrientation();
   window.addEventListener('orientationchange', updateScreenOrientation);

   function onDeviceOrientation(event) {
     deviceAlpha = THREE.MathUtils.degToRad(event.alpha || 0); // Z
     deviceBeta  = THREE.MathUtils.degToRad(event.beta  || 0); // X'
     deviceGamma = THREE.MathUtils.degToRad(event.gamma || 0); // Y''
   }

   async function requestGyroPermissionIfNeeded() {
     try {
       if (typeof DeviceOrientationEvent !== 'undefined' &&
           typeof DeviceOrientationEvent.requestPermission === 'function') {
         const res = await DeviceOrientationEvent.requestPermission();
         return res === 'granted';
       }
       return true; // non-iOS / older iOS where permission isn't required
     } catch (e) {
       return false;
     }
   }

   function attachGyro() {
     if (gyroListenerAttached) return;
     window.addEventListener('deviceorientation', onDeviceOrientation, { passive: true });
     gyroListenerAttached = true;
   }
   function detachGyro() {
     if (!gyroListenerAttached) return;
     window.removeEventListener('deviceorientation', onDeviceOrientation);
     gyroListenerAttached = false;
   }

   function calibrateGyroNow() {
     const deviceQ = new THREE.Quaternion();
     setObjectQuaternion(deviceQ, deviceAlpha, deviceBeta, deviceGamma, screenOrientRad);
     gyroCalibrationOffset.copy(deviceQ).invert(); // store inverse so (offset * deviceQ) recenters
     hasCalibratedThisSession = true;
     const overlay = document.getElementById('vrCalibrateOverlay');
     if (overlay) overlay.classList.remove('show');
     logToTerminal("Gyro calibrated. Center position locked.");
   }

   function showCalibrateOverlay() {
     const overlay = document.getElementById('vrCalibrateOverlay');
     if (overlay) overlay.classList.add('show');
   }

   function setVRUI(active) {
     document.body.classList.toggle('vr-active', active);
     const hud = document.getElementById('vrHUD');
     if (hud) hud.classList.toggle('active', active);
   }

   async function enterVR() {
     if (vrMode) return;
     vrMode = true;
     setVRUI(true);

     // Disable 2D interactions that can trigger redirects accidentally
     logToTerminal("IMMERSIVE MODE requested… (single-screen, gyro + geo navigation)");

     // Permission request (iOS 13+)
     const ok = await requestGyroPermissionIfNeeded();
     if (!ok) {
       logToTerminal("Gyro permission denied or unavailable. Immersive rotation fallback engaged.");
     } else {
       attachGyro();
     }

     // Optional: location-based drift (best effort)
     await startGeo();

     // In VR, gyro rotation overrides auto-camera + mouse rotation
     autoCameraEnabled = false;
     document.getElementById('toggleAutoCamera').checked = false;

     // Prompt calibration
     hasCalibratedThisSession = false;
     showCalibrateOverlay();
     logToTerminal("VR MODE ACTIVE. Calibrate to lock your forward direction.");
   }

   function exitVR() {
     if (!vrMode) return;
     vrMode = false;
     setVRUI(false);
     detachGyro();
     stopGeo();
     // restore classic rotation targets so it doesn't "snap" weirdly
     targetCameraRotation.copy(camera.rotation);
     logToTerminal("VR mode exited. Traditional controls restored.");
   }


   // For organic navigation: target positions and rotations
   let targetCameraPosition = new THREE.Vector3().copy(camera.position);
   let targetCameraRotation = new THREE.Euler().copy(camera.rotation);

   // Enable right-click drag for rotation (prevent default context menu)
   canvas.addEventListener('contextmenu', (e) => { e.preventDefault(); }, false);
   let isRotating = false, previousMouseRotation = { x: 0, y: 0 };
   canvas.addEventListener('mousedown', (e) => {
     // Use right mouse button for rotation
     if (e.button === 2) {
       if (vrMode) return;
       isRotating = true;
       previousMouseRotation = { x: e.clientX, y: e.clientY };
     }
   });
   canvas.addEventListener('mousemove', (e) => {
     if (isRotating && !autoCameraEnabled && !vrMode) {  // Allow manual control when auto-camera is off
       let deltaX = e.clientX - previousMouseRotation.x;
       let deltaY = e.clientY - previousMouseRotation.y;
       targetCameraRotation.y -= deltaX * 0.005;
       targetCameraRotation.x -= deltaY * 0.005;
       previousMouseRotation = { x: e.clientX, y: e.clientY };
     }
   });
   canvas.addEventListener('mouseup', (e) => {
     if (e.button === 2) {
       if (vrMode) return; isRotating = false; }
   });

   // Create a particle system with gravitational physics and chaotic behavior
   function createParticles(count) {
     if (particleSystem) scene.remove(particleSystem);

     const geometry = new THREE.BufferGeometry();
     const positions = new Float32Array(count * 3);
     const velocities = new Float32Array(count * 3);
     const colors = new Float32Array(count * 3);

     for (let i = 0; i < count; i++) {
       positions[i * 3]     = (Math.random() - 0.5) * 2000;
       positions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
       positions[i * 3 + 2] = (Math.random() - 0.5) * 2000;
       velocities[i * 3]     = (Math.random() - 0.5) * 0.1;
       velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
       velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
       // Initialize with white; will be modulated dynamically
       colors[i * 3]     = 1.0;
       colors[i * 3 + 1] = 1.0;
       colors[i * 3 + 2] = 1.0;
     }

     geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
     geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
     geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

     particleMaterial = new THREE.PointsMaterial({
       size: 2,
       vertexColors: true,
       transparent: true,
       opacity: 0.7
     });

     particleSystem = new THREE.Points(geometry, particleMaterial);
     scene.add(particleSystem);
   }
   // Default to medium resolution (20,000 particles)
   particleCount = resolutionSettings.medium;
   createParticles(particleCount);

   // Global audio multiplier (affects visual vibrance)
   let audioMultiplier = 1;

   // Array to hold nebula objects
   const nebulas = [];

   // Create nebulas/galactic formations (irregular, pulsating, organic)
   function createNebulas() {
     // Create 5 nebulas
     for (let i = 0; i < 5; i++) {
       const nebulaCanvas = document.createElement('canvas');
       nebulaCanvas.width = 256;
       nebulaCanvas.height = 256;
       const ctx = nebulaCanvas.getContext('2d');
       const gradient = ctx.createRadialGradient(128, 128, 20, 128, 128, 128 + Math.random() * 50);
       gradient.addColorStop(0, "rgba(255,255,255,0.8)");
       gradient.addColorStop(0.3, "rgba(" +
         (Math.floor(Math.random()*100)+155) + "," +
         (Math.floor(Math.random()*100)+155) + "," +
         (Math.floor(Math.random()*100)+155) + ",0.6)");
       gradient.addColorStop(0.7, "rgba(50,50,200,0.3)");
       gradient.addColorStop(1, "rgba(0,0,0,0)");
       ctx.fillStyle = gradient;
       ctx.fillRect(0, 0, 256, 256);
       const texture = new THREE.CanvasTexture(nebulaCanvas);
       const material = new THREE.SpriteMaterial({ map: texture, transparent: true, blending: THREE.AdditiveBlending });
       const sprite = new THREE.Sprite(material);
       sprite.position.set((Math.random()-0.5)*1500, (Math.random()-0.5)*1500, (Math.random()-0.5)*1500);
       sprite.scale.set(300, 300, 1);
       sprite.userData = {
         velocity: new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2),
         pulsationAmplitude: Math.random() * 0.5 + 0.5,
         pulsationPhase: Math.random() * Math.PI * 2
       };
       scene.add(sprite);
       nebulas.push(sprite);
     }
   }
   createNebulas();

   /********************************************************************
    * INTERACTIVE SHIMMERING STARS
    ********************************************************************/
   // Array to hold our interactive stars
   const interactiveStars = [];

   // Create a shimmering star (as a THREE.Sprite) that when hovered or clicked zooms in and redirects
   // position: THREE.Vector3, color: an object with r,g,b (0-255), url: redirection URL,
   // size: base size in pixels, isDark (optional): flag for the dark matter star
   function createInteractiveStar(position, color, url, size = 50, isDark = false) {
     const starCanvas = document.createElement('canvas');
     starCanvas.width = 128;
     starCanvas.height = 128;
     const ctx = starCanvas.getContext('2d');
     const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
     if (isDark) {
       // For the dark matter star: deep, glitched colors
       gradient.addColorStop(0, "rgba(20,20,20,1)");
       gradient.addColorStop(0.5, "rgba(10,10,10,0.8)");
       gradient.addColorStop(1, "rgba(0,0,0,0)");
     } else {
       // For the vibrant stars: use the provided color values
       gradient.addColorStop(0, `rgba(${color.r},${color.g},${color.b},1)`);
       gradient.addColorStop(0.5, `rgba(${color.r},${color.g},${color.b},0.5)`);
       gradient.addColorStop(1, "rgba(0,0,0,0)");
     }
     ctx.fillStyle = gradient;
     ctx.fillRect(0, 0, 128, 128);

     const texture = new THREE.CanvasTexture(starCanvas);
     const material = new THREE.SpriteMaterial({ map: texture, transparent: true, blending: THREE.AdditiveBlending });
     const sprite = new THREE.Sprite(material);
     sprite.position.copy(position);
     sprite.scale.set(size, size, 1);
     // Store the URL and set up hover tracking variables
     sprite.userData = { url: url, hoverStart: null, triggered: false, isDark: isDark };
     interactiveStars.push(sprite);
     scene.add(sprite);
     return sprite;
   }

   // Create our exquisite stars:
   // 1. A brilliant star (redirects to stocks)
   createInteractiveStar(new THREE.Vector3(-500, 300, 0), {r:255, g:200, b:50}, "https://donutz.ai/stocks", 50);
   // 2. An enigmatic star (redirects to crypto)
   createInteractiveStar(new THREE.Vector3(400, -200, 0), {r:50, g:255, b:200}, "https://donutz.ai/crypto", 50);
   // 3. A wicked, eclectic star (redirects to GoDaddy)
   createInteractiveStar(new THREE.Vector3(200, 400, 0), {r:200, g:50, b:255}, "https://gozaddy.ai", 50);
   // 4. A dark matter, glitched star (redirects to the anti-philosophical domain)
   createInteractiveStar(new THREE.Vector3(0, -400, 0), {r:20, g:20, b:20}, "https://xXDaemonLoverXx.ai", 70, true);

   // Raycaster and mouse vector for detecting interactions
   const raycaster = new THREE.Raycaster();
   const mouse = new THREE.Vector2();

   // Update mouse coordinates on move (needed for both control panel and star interactions)
   document.addEventListener('mousemove', (event) => {
     mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
     mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
   });

   // On click: if an interactive star is clicked, trigger its zoom animation and redirect
   document.addEventListener('click', (event) => {
     if (vrMode) return;
     raycaster.setFromCamera(mouse, camera);
     const intersects = raycaster.intersectObjects(interactiveStars);
     if (intersects.length > 0) {
       const star = intersects[0].object;
       zoomToStar(star, star.userData.url);
     }
   });

   // Function to animate a zoom-in effect toward a star before redirecting
   function zoomToStar(star, url) {
     const duration = 1500; // in milliseconds
     const startTime = performance.now();
     const startPos = camera.position.clone();
     const targetPos = star.position.clone();
     function animateZoom() {
       const t = (performance.now() - startTime) / duration;
       if (t < 1) {
         camera.position.lerpVectors(startPos, targetPos, t);
         requestAnimationFrame(animateZoom);
       } else {
         window.location.href = url;
       }
     }
     animateZoom();
   }

   /********************************************************************
    * MAIN ANIMATION LOOP
    ********************************************************************/
   function animate() {
     requestAnimationFrame(animate);
     const time = performance.now() * 0.001;

     // Univerzine sign: gentle float + subtle neon flicker
     if (univerzineSign) {
       univerzineSign.position.y = univerzineSign.userData.baseY + Math.sin(time * 0.9) * 10;
       const flick = 0.92 + 0.10 * Math.sin(time * 18 + univerzineSign.userData.flickerSeed) + 0.06 * Math.sin(time * 41 + 1.7*univerzineSign.userData.flickerSeed);
       univerzineSign.material.opacity = Math.max(0.55, Math.min(1.0, flick));
     }

     // Auto-Camera Angling (modulated by audio beats)
     if (autoCameraEnabled) {
       let audioFactor = (audioAverage / 256 - 0.5) * 0.5;
       targetCameraRotation.x = Math.sin(time * 0.5) * 0.3 + audioFactor;
       targetCameraRotation.y = Math.cos(time * 0.5) * 0.3 + audioFactor;
     }

     // Smoothly update camera position and rotation (using a slightly lower lerp factor for smoother motion)
     camera.position.lerp(targetCameraPosition, 0.08);

     if (vrMode && gyroListenerAttached) {
       // Gyro-only rotation (full XYZ via quaternion); smooth via slerp
       const deviceQ = new THREE.Quaternion();
       setObjectQuaternion(deviceQ, deviceAlpha, deviceBeta, deviceGamma, screenOrientRad);

       const targetQ = new THREE.Quaternion();
       targetQ.copy(gyroCalibrationOffset).multiply(deviceQ);

       camera.quaternion.slerp(targetQ, 0.15);
     } else {
       camera.rotation.x = THREE.MathUtils.lerp(camera.rotation.x, targetCameraRotation.x, 0.08);
       camera.rotation.y = THREE.MathUtils.lerp(camera.rotation.y, targetCameraRotation.y, 0.08);
     }

     // Update base color (dynamic or preset)
     if (dynamicColorsEnabled) {
       baseColor.r = Math.abs(Math.sin(time + 0));
       baseColor.g = Math.abs(Math.sin(time + 2));
       baseColor.b = Math.abs(Math.sin(time + 4));
     } else {
       const scheme = colorSchemes[selectedColorScheme];
       baseColor.r = scheme.r;
       baseColor.g = scheme.g;
       baseColor.b = scheme.b;
     }

     // Update particles: gravitational pull, chaos factor, and audio responsiveness
     const positions = particleSystem.geometry.attributes.position.array;
     const velocities = particleSystem.geometry.attributes.velocity.array;
     const colors = particleSystem.geometry.attributes.color.array;
     const chaosFactor = 1 + 0.5 * Math.sin(time * 0.2);
     for (let i = 0; i < particleCount; i++) {
       const idx = i * 3;
       let x = positions[idx], y = positions[idx + 1], z = positions[idx + 2];
       const dx = -x, dy = -y, dz = -z;
       const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.0001;
       const force = (0.05 * chaosFactor) / (dist * dist);
       velocities[idx]     += (dx / dist) * force;
       velocities[idx + 1] += (dy / dist) * force;
       velocities[idx + 2] += (dz / dist) * force;
       positions[idx]     += velocities[idx];
       positions[idx + 1] += velocities[idx + 1];
       positions[idx + 2] += velocities[idx + 2];
       if (dist < 50) {
         colors[idx]     *= 0.99;
         colors[idx + 1] *= 0.99;
         colors[idx + 2] *= 0.99;
       }
       const boundary = 1000;
       if (x > boundary || x < -boundary) positions[idx] = -x;
       if (y > boundary || y < -boundary) positions[idx + 1] = -y;
       if (z > boundary || z < -boundary) positions[idx + 2] = -z;
       const speed = Math.sqrt(velocities[idx]**2 + velocities[idx+1]**2 + velocities[idx+2]**2);
       const intensity = Math.min(speed * 50 * audioMultiplier, 1);
       const shimmer = 0.05 * Math.sin(time * 10 + i);
       colors[idx]     = Math.min(1, baseColor.r * (0.5 + 0.5 * intensity) + shimmer);
       colors[idx + 1] = Math.min(1, baseColor.g * (0.5 + 0.5 * intensity) + shimmer);
       colors[idx + 2] = Math.min(1, baseColor.b * (0.5 + 0.5 * intensity) + shimmer);
     }
     particleSystem.geometry.attributes.position.needsUpdate = true;
     particleSystem.geometry.attributes.color.needsUpdate = true;

     // Update nebulas: pulsate and drift
     for (let i = 0; i < nebulas.length; i++) {
       let nebula = nebulas[i];
       let gravForce = nebula.position.clone().normalize().multiplyScalar(-0.001);
       nebula.userData.velocity.add(gravForce);
       nebula.position.add(nebula.userData.velocity);
       let scaleFactor = 1 + Math.sin(time * nebula.userData.pulsationAmplitude + nebula.userData.pulsationPhase) * 0.2;
       nebula.scale.set(300 * scaleFactor, 300 * scaleFactor, 1);
     }

     // Occasionally spawn a UFO
     if (Math.random() < 0.001) {
       spawnUFO();
     }

     // Process interactive star hover events using raycasting:
     if (!vrMode) {
     raycaster.setFromCamera(mouse, camera);
     const starIntersects = raycaster.intersectObjects(interactiveStars);
     const now = performance.now();
     for (let star of interactiveStars) {
       // If the star is under the mouse pointer…
       if (starIntersects.find(i => i.object === star)) {
         if (!star.userData.hoverStart) star.userData.hoverStart = now;
         // If hovered for longer than 3.1415 seconds and not yet triggered, zoom in & redirect
         if (!star.userData.triggered && (now - star.userData.hoverStart) > 3141.5) {
           star.userData.triggered = true;
           zoomToStar(star, star.userData.url);
         }
       } else {
         star.userData.hoverStart = null;
         star.userData.triggered = false;
       }
       // Add a pulsing (shimmering) effect to each star:
       let pulse = 1 + 0.2 * Math.sin(time * 5 + star.position.x);
       let baseSize = star.userData.isDark ? 70 : 50;
       star.scale.set(baseSize * pulse, baseSize * pulse, 1);
     }

     }

     // Render the scene (single-screen; VR changes controls, not viewport)
     renderer.render(scene, camera);
   }
   animate();

   // Adjust canvas on window resize
   window.addEventListener('resize', () => {
     camera.aspect = window.innerWidth / window.innerHeight;
     camera.updateProjectionMatrix();
     renderer.setSize(window.innerWidth, window.innerHeight);
   });

   /****************************
    * Audio Sensitivity Module (Enhanced)
    ****************************/
   let audioContext, analyser;
   function initAudio() {
     if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia && audioEnabled) {
       navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
         audioContext = new (window.AudioContext || window.webkitAudioContext)();
         analyser = audioContext.createAnalyser();
         const microphone = audioContext.createMediaStreamSource(stream);
         microphone.connect(analyser);
         analyser.fftSize = 256;
         const bufferLength = analyser.frequencyBinCount;
         const dataArray = new Uint8Array(bufferLength);
         function analyzeAudio() {
           if (!audioEnabled) return;
           analyser.getByteFrequencyData(dataArray);
           let sum = 0;
           for (let i = 0; i < bufferLength; i++) {
             sum += dataArray[i];
           }
           const average = sum / bufferLength;
           audioAverage = average;
           particleMaterial.size = 2 + average / 40;
           particleMaterial.opacity = 0.5 + average / 400;
           audioMultiplier = 1 + (average / 256);
           requestAnimationFrame(analyzeAudio);
         }
         analyzeAudio();
         logToTerminal("Audio input initialized. The cosmic AI listens to your every sound.");
       }).catch((err) => {
         logToTerminal("Audio input error: " + err);
       });
     }
   }
   initAudio();

   // Resume audio context on user interaction
   document.addEventListener('click', () => {
     if (audioContext && audioContext.state === 'suspended') {
       audioContext.resume();
     }
   });

   /****************************
    * Device Orientation & Touch Controls
    ****************************/
   if (orientationEnabled) {
     window.addEventListener('deviceorientation', (event) => {
       if (!orientationEnabled || autoCameraEnabled) return;
       const beta = event.beta || 0;
       const gamma = event.gamma || 0;
       targetCameraRotation.x = THREE.MathUtils.lerp(targetCameraRotation.x, (beta / 90) * 0.5, 0.1);
       targetCameraRotation.y = THREE.MathUtils.lerp(targetCameraRotation.y, (gamma / 90) * 0.5, 0.1);
     });
   }

   // Left mouse button drag for translation
   let isDragging = false;
   let previousMousePosition = { x: 0, y: 0 };
   renderer.domElement.addEventListener('mousedown', (e) => {
     if (e.button === 0) {
       isDragging = true;
       previousMousePosition = { x: e.clientX, y: e.clientY };
     }
   });
   renderer.domElement.addEventListener('mousemove', (e) => {
     if (isDragging) {
       const deltaMove = { x: e.clientX - previousMousePosition.x, y: e.clientY - previousMousePosition.y };
       targetCameraPosition.x -= deltaMove.x;
       targetCameraPosition.y += deltaMove.y;
       previousMousePosition = { x: e.clientX, y: e.clientY };
     }
   });
   renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });

   // Touch controls: drag for translation and pinch-to-zoom
   let lastTouch = null;
   let lastTouchDistance = null;
   renderer.domElement.addEventListener('touchstart', (e) => {
     if (e.touches.length === 2) {
       const dx = e.touches[0].pageX - e.touches[1].pageX;
       const dy = e.touches[0].pageY - e.touches[1].pageY;
       lastTouchDistance = Math.hypot(dx, dy);
     } else if (e.touches.length === 1) {
       lastTouch = e.touches[0];
     }
   }, { passive: false });
   renderer.domElement.addEventListener('touchmove', (e) => {
     if (e.touches.length === 2) {
       const dx = e.touches[0].pageX - e.touches[1].pageX;
       const dy = e.touches[0].pageY - e.touches[1].pageY;
       const currentDistance = Math.hypot(dx, dy);
       if (lastTouchDistance !== null) {
         const delta = currentDistance - lastTouchDistance;
         targetCameraPosition.z = camera.position.z - delta * 0.5;
         lastTouchDistance = currentDistance;
       }
       e.preventDefault();
     } else if (e.touches.length === 1 && touchEnabled) {
       const touch = e.touches[0];
       if (lastTouch) {
         const deltaMove = { x: touch.clientX - lastTouch.clientX, y: touch.clientY - lastTouch.clientY };
         targetCameraPosition.x -= deltaMove.x;
         targetCameraPosition.y += deltaMove.y;
       }
       lastTouch = touch;
     }
   }, { passive: false });

   // Trackpad / Mouse Wheel Zoom for desktop
   document.addEventListener("wheel", (e) => {
     targetCameraPosition.z = camera.position.z + e.deltaY * 0.5;
   });

   /****************************
    * UI Controls and Optional Feature Toggles
    ****************************/
   let controlsTimeout;
   let uiTimeout;
   function bumpUIVisibility(){
     if (vrMode) return; // VR hides 2D UI
     document.body.classList.remove('ui-hidden');
     clearTimeout(uiTimeout);
     uiTimeout = setTimeout(()=>{ document.body.classList.add('ui-hidden'); }, 2500);
   }

   // Keep the original controls panel behavior, but now hide *all* UI after inactivity.
   document.addEventListener("mousemove", () => {
     const controlsDiv = document.getElementById("controls");
     if (controlsDiv) controlsDiv.style.opacity = 1;
     clearTimeout(controlsTimeout);
     controlsTimeout = setTimeout(() => { if (controlsDiv) controlsDiv.style.opacity = 0; }, 2500);
     bumpUIVisibility();
   });

   document.addEventListener("touchstart", bumpUIVisibility, { passive: true });
   document.addEventListener("keydown", bumpUIVisibility);
   // start hidden by default
   document.body.classList.add('ui-hidden');

   document.getElementById('resolutionSelector').addEventListener('change', (e) => {
     const res = e.target.value;
     particleCount = resolutionSettings[res];
     createParticles(particleCount);
     logToTerminal("Resolution set to: " + res + " (" + particleCount + " particles)");
   });

   document.getElementById('grandmasterBtn').addEventListener('click', () => {
     particleCount = resolutionSettings.grandmaster;
     createParticles(particleCount);
     logToTerminal("GRANDMASTER RESOLUTION activated: " + particleCount + " particles");
   });

   document.getElementById('fullscreenBtn').addEventListener('click', () => {
     if (!document.fullscreenElement) {
       document.documentElement.requestFullscreen();
     } else {
       document.exitFullscreen();
     }
   });

   // ===== VR Controls =====
   const vrBtn = document.getElementById('vrBtn');
   const calibrateBtn = document.getElementById('calibrateBtn');
   const vrCalBtn = document.getElementById('vrCalibrateBtn');
   const vrCloseCalBtn = document.getElementById('vrCloseCalibrateBtn');
   const vrExitBtnTop = document.getElementById('vrExitBtnTop');

   function refreshVRButtonLabel(){
     if (!vrBtn) return;
     vrBtn.textContent = vrMode ? 'Exit VR' : 'Enter VR';
   }
   refreshVRButtonLabel();

   if (vrBtn) vrBtn.addEventListener('click', async () => {
     if (vrMode) exitVR();
     else await enterVR();
     refreshVRButtonLabel();
   });

   if (calibrateBtn) calibrateBtn.addEventListener('click', () => {
     // If not in VR, this just opens a helpful prompt; if in VR, it calibrates now.
     if (!vrMode) {
       logToTerminal("Calibration is primarily for VR gyro. Enter VR to use gyro-only rotation.");
       showCalibrateOverlay();
     } else {
       showCalibrateOverlay();
     }
   });

   if (vrCalBtn) vrCalBtn.addEventListener('click', calibrateGyroNow);
   if (vrCloseCalBtn) vrCloseCalBtn.addEventListener('click', () => {
     const overlay = document.getElementById('vrCalibrateOverlay');
     if (overlay) overlay.classList.remove('show');
   });
   if (vrExitBtnTop) vrExitBtnTop.addEventListener('click', () => {
     exitVR();
     refreshVRButtonLabel();
     const overlay = document.getElementById('vrCalibrateOverlay');
     if (overlay) overlay.classList.remove('show');
   });

   // Keyboard shortcut: V toggles VR, C opens calibration
   window.addEventListener('keydown', async (e) => {
     if (e.key === 'v' || e.key === 'V') {
       if (vrMode) exitVR();
       else await enterVR();
       refreshVRButtonLabel();
     }
     if (e.key === 'c' || e.key === 'C') {
       showCalibrateOverlay();
     }
     if (e.key === 'Escape' && vrMode) {
       exitVR();
       refreshVRButtonLabel();
     }
   });

   // Optional feature toggles
   document.getElementById('toggleAudio').addEventListener('change', (e) => {
     audioEnabled = e.target.checked;
     if (audioEnabled) initAudio();
     logToTerminal("Audio Sensitivity " + (audioEnabled ? "enabled" : "disabled") + ".");
   });
   document.getElementById('toggleOrientation').addEventListener('change', async (e) => {
     orientationEnabled = e.target.checked;

     if (orientationEnabled) {
       const ok = await requestGyroPermissionIfNeeded();
       if (ok) attachGyro();
       else logToTerminal("Device Orientation permission denied/unavailable.");
     } else {
       // If VR is active we keep gyro listener state tied to VR; otherwise detach.
       if (!vrMode) detachGyro();
     }

     logToTerminal("Device Orientation " + (orientationEnabled ? "enabled" : "disabled") + ".");
   });
   document.getElementById('toggleTouch').addEventListener('change', (e) => {
     touchEnabled = e.target.checked;
     logToTerminal("Touch Controls " + (touchEnabled ? "enabled" : "disabled") + ".");
   });
   document.getElementById('toggleAutoCamera').addEventListener('change', (e) => {
     autoCameraEnabled = e.target.checked;
     logToTerminal("Auto-Camera Angling " + (autoCameraEnabled ? "enabled" : "disabled") + ".");
   });
   document.getElementById('toggleGlitch').addEventListener('change', (e) => {
     glitchEnabled = e.target.checked;
     canvas.classList.toggle('glitch', glitchEnabled);
     logToTerminal("Glitch Effects " + (glitchEnabled ? "enabled" : "disabled") + ".");
   });
   document.getElementById('toggleDynamic').addEventListener('change', (e) => {
     dynamicColorsEnabled = e.target.checked;
     logToTerminal("Dynamic Colors " + (dynamicColorsEnabled ? "enabled" : "disabled") + ".");
   });
   document.getElementById('colorSchemeSelector').addEventListener('change', (e) => {
     selectedColorScheme = e.target.value;
     logToTerminal("Color scheme set to: " + selectedColorScheme);
   });

   function logToTerminal(message) {
     const terminal = document.getElementById('terminal');
     terminal.innerText += "\n" + message;
     terminal.scrollTop = terminal.scrollHeight;
   }


   window.addEventListener('pagehide', () => { detachGyro(); stopGeo(); });
   logToTerminal("CosmicDashboard initialized. Welcome to your Cosmic Dashboard! Swim freely within this living, breathing, augmented hyper-dimensional AI-Interface. Enjoy the transcendent journey through exquisite stars and dark matter mysteries.");
 </script>

  <!-- ⬇ Terminal toggle & helpers (non-destructive) -->
  <script>
  (function(){
    const term = document.getElementById('terminal');
    const btn  = document.getElementById('termToggle');

    function toggleTerm(){ if(!term) return; term.classList.toggle('is-open'); }
    if(btn) btn.addEventListener('click', toggleTerm);
    window.addEventListener('keydown', (e)=>{ if(e.key==='t' || e.key==='T') toggleTerm(); });

    // Safe logger shim (keeps only last 500 lines)
    if (term && !window.logToTerminal) {
      window.logToTerminal = function(message){
        try{
          term.textContent += (term.textContent ? "\n" : "") + String(message);
          const lines = term.textContent.split("\n");
          if(lines.length > 500) term.textContent = lines.slice(-500).join("\n");
          term.scrollTop = term.scrollHeight;
        }catch(e){ /* no-op */ }
      };
    }

    // Perf hints: dispatch pause/resume events other scripts can listen to (optional).
    document.addEventListener('visibilitychange', ()=>{
      const ev = new Event(document.hidden ? 'cosmic:pause' : 'cosmic:resume');
      document.dispatchEvent(ev);
    });
  })();
  </script>

</body>
</html>
